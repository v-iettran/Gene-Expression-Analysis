---
title: "Breast Cancer Gene Expression Analysis"
author: "Viet Tran - 25216938"
format: pdf
editor: visual
---

# 1. Data Preprocessing

## Load required libraries

```{r, message=FALSE}
library(dplyr)
library(tidyr)
library(DESeq2)
library(ggplot2)

# Set path to the data directory (adjust if needed)
downloads_path  = '/Users/luke/Desktop/UCD/Class/Bio Principle'
file_path = paste(downloads_path,"brca_tcga_pan_can_atlas_2018.tar.gz", sep = "/" )

# Extract the tar.gz file if not already extracted
# Note: This will create a folder in the current working directory
untar(file_path)

# Set the path to the extracted folder
folder_path = paste(getwd(),"brca_tcga_pan_can_atlas_2018", sep = "/" )
```

## Load the main data files

```{r}
# Define paths to the three main data files
rna_seq_path = paste(folder_path,"data_mrna_seq_v2_rsem.txt", sep = "/")
patient_data_path = paste(folder_path,"data_clinical_patient.txt", sep = "/")
copy_number_aberrations_path = paste(folder_path,"data_cna.txt", sep = "/")

# Read the data files
# rna_seq: RNA sequencing expression data (genes x patients)
# data_patient: Clinical patient data
# cna: Copy number aberration data (genes x patients)
rna_seq = read.delim(rna_seq_path)
data_patient = read.delim(patient_data_path)
cna = read.delim(copy_number_aberrations_path)
```

## Inspect the loaded data

```{r}
# Preview the structure of each dataset
head(rna_seq)      
head(cna)          
head(data_patient)
```

## Clean patient clinical data

```{r}
# Remove the first 4 rows of data_patient (these are metadata rows)
# Keep rows 5-1088 which contain the actual patient data
data_patient = data_patient[5:1088,]

# Reset row names to sequential numbers
row.names(data_patient) <- 1:nrow(data_patient)
head(data_patient)
```

## Standardize patient IDs across datasets

```{r}
# Create a function to reformat patient IDs to make them consistent across datasets
# TCGA patient IDs need to be standardized to 12-character format (e.g., TCGA-XX-XXXX)
clean_id = function(x) {
  x = substr(x, 1, 12)           # Take first 12 characters
  x = gsub("\\.", "-", x)        # Replace dots with dashes
  x
}

# Reformat patient IDs in each dataset
# RNA Seq patient IDs (columns 3 onwards are patient IDs, first 2 are gene info)
colnames(rna_seq)[-(1:2)] <- clean_id(colnames(rna_seq)[-(1:2)])

# CNA patient IDs (columns 3 onwards are patient IDs, first 2 are gene info)
colnames(cna)[-(1:2)] <- clean_id(colnames(cna)[-(1:2)])

# Clinical data patient IDs
data_patient$X.Patient.Identifier <- clean_id(data_patient$X.Patient.Identifier)

# Convert to long format for merging
# This transforms wide format (genes x patients) to long format (one row per gene-patient)
rna_long <- rna_seq |>
  pivot_longer(
    cols = -c(Hugo_Symbol, Entrez_Gene_Id),
    names_to = "Patient_ID",
    values_to = "RNA"
  )

cna_long <- cna |>
  pivot_longer(
    cols = -c(Hugo_Symbol, Entrez_Gene_Id),
    names_to = "Patient_ID",
    values_to = "CNA"
  )

# Find common patient IDs across all three datasets
# This ensures we only analyze patients with data in all three datasets
common_ids = intersect(intersect(
  unique(rna_long$Patient_ID), 
  unique(cna_long$Patient_ID)
), unique(data_patient$X.Patient.Identifier))

# Filter each dataset to only include common patient IDs
rna_seq = rna_seq[, c(colnames(rna_seq)[1:2], common_ids)]
cna = cna[, c(colnames(cna)[1:2], common_ids)]
data_patient = data_patient[
  data_patient$X.Patient.Identifier %in% common_ids, 
]

# Merge all three datasets into one consolidated dataset
merged = rna_long |>
  inner_join(cna_long,
             by = c("Hugo_Symbol", "Entrez_Gene_Id", "Patient_ID"),
             relationship = "many-to-many") |>
  inner_join(data_patient,
             by = c("Patient_ID" = "X.Patient.Identifier"))

# Select only the columns we need for analysis
merged = dplyr::select(
  merged,
  Hugo_Symbol,
  Entrez_Gene_Id,
  Patient_ID,
  RNA,
  CNA,
  Diagnosis.Age,
  Neoplasm.Disease.Stage.American.Joint.Committee.on.Cancer.Code,
  Overall.Survival.Status,
  `Overall.Survival..Months.`
)
```

## Check the structure of the merged dataset

```{r}
# Display the structure of the merged dataset
str(merged)
```

# 2. Exploratory data analysis

```{r}
# Find column indices for key clinical variables
col_age = which(colnames(data_patient)=='Diagnosis.Age')
col_stage = which(colnames(data_patient) == "Neoplasm.Disease.Stage.American.Joint.Committee.on.Cancer.Code")
col_OS = which(colnames(data_patient) == "Overall.Survival.Status")
col_OS_T = which(colnames(data_patient) == "Overall.Survival..Months.")

# Plot 1: Histogram of age at diagnosis
hist(as.numeric(data_patient[,col_age]), 
     main = "Histogram of Age at Diagnosis", 
     breaks = 50, 
     xlab = "Age at Diagnosis")

# Plot 2: Histogram of cancer stage
# Clean stage data: simplify stage notation (e.g., IA, IB -> I)
stage = data_patient[,col_stage]
stage = gsub("I[^VI]", "I", stage)  # Convert IA, IB, IC to I
stage = gsub("V[^\\s]", "V", stage)  # Handle stage V variants

barplot(table(as.factor(stage)),  
        main = "Histogram of Diagnosed Stage", 
        ylab="Frequency", 
        las = 2, 
        cex.names = 1)

# Plot 3: Histogram of survival times (only for deceased patients)
# Uncensored = patients who have died (we know their exact survival time)
uncensored = which(data_patient[,col_OS] == "1:DECEASED")
hist(as.numeric(data_patient[uncensored,col_OS_T]), 
     breaks = 50, 
     main = "Histogram of Overall survival Months", 
     xlab = "Survival (in months)")
```

# 3. Pathway Enrichment Analysis

## Prepare data for DESeq2 analysis

```{r}
# Create count matrix for DESeq2 (genes x patients)
# Round RNA-seq values to integers (DESeq2 requires integer counts)
assay = round(as.matrix(rna_seq[, -c(1,2)]))
rownames(assay) = rna_seq[, 1]  # Gene symbols as row names
pat_ids = data_patient[,1]      # Patient IDs from clinical data

# Create ordered factor for cancer stage
# Note: stage variable was created in previous chunk
stage_factor = factor(stage, ordered = T, 
                      levels = c("STAGE I", "STAGE II","STAGE III","STAGE IV", "STAGE X", NA))

# Convert CNA data to long format
cna_long = cna |>
  pivot_longer(cols = -c(Hugo_Symbol, Entrez_Gene_Id),
               names_to = "Patient_ID",
               values_to = "CNA")

# Identify patients with ERBB2 amplification (CNA > 0)
amplified_patient = cna_long |>
  filter(Hugo_Symbol == "ERBB2", CNA > 0)

amplified_patient_id = amplified_patient$Patient_ID

# Create metadata matrix for DESeq2
# Columns: Early (age < 55), Stage, ERBB2 (amplified = 1, not = 0)
metadata = matrix(0, dim(assay)[2], 3)

for (i in 1:dim(assay)[2]) {
  pat_barcode = colnames(assay)[i]
  
  # Find matching patient in clinical data
  idx = which(pat_barcode == pat_ids)
  
  # Column 1: Early diagnosis (1 if age < 55, 0 otherwise)
  metadata[i, 1] = 1*(as.numeric(data_patient[idx,col_age])<55)
  
  # Column 2: Cancer stage
  metadata[i,2] = stage_factor[idx]
  
  # Column 3: ERBB2 amplification status (1 if amplified, 0 otherwise)
  metadata[i,3] = ifelse(pat_barcode %in% amplified_patient_id, 1, 0)
}

# Clean metadata: replace NAs with 0, replace stage X with 0
metadata[is.na(metadata)] = 0
metadata[metadata[,2] == 5, 2] = 0  # Stage X -> 0
colnames(metadata) = c("Early", "Stage", "ERBB2")
```

## Filter and prepare data for DESeq2

```{r, message=FALSE}
# Clean assay matrix: remove NAs and negative values
assay[is.na(assay)] = 0
assay[assay < 0] = 0

# Filter genes: keep only genes with at least 10 counts in at least 3 samples
# This removes lowly expressed genes that would not be informative
smallestGroupSize = 3
keep = rowSums(assay >= 10) >= smallestGroupSize

assay = assay[keep,]

# Create DESeq2 dataset object
# Design formula: ~ ERBB2 means we're comparing ERBB2 amplified vs non-amplified
dds = DESeqDataSetFromMatrix(countData = assay,
                              colData = metadata,
                              design = ~ ERBB2)
```

## Run differential expression analysis

```{r}
# Perform differential expression analysis
# This fits negative binomial models and tests for differential expression
dds = DESeq(dds)

# Check available comparisons
resultsNames(dds)

# Extract results for ERBB2 comparison (amplified vs non-amplified)
# alpha = 0.05 is the significance threshold
res = results(dds, alpha = 0.05)

# Filter for significantly differentially expressed genes
# We only consider genes with adjusted p-value < 0.05 (FDR correction)
# abs(log2FoldChange) > 0 means we only consider genes with any fold change in either directions
significant_res = res[res$padj < 0.05 & abs(res$log2FoldChange) > 0 , ]

# View top 10 most significantly differentially expressed genes
significant_res[order(significant_res$padj)[1:10], ]
```

## Principal Component Analysis (PCA)

```{r}
# Apply variance stabilizing transformation (VST) for visualization
# VST normalizes the data and stabilizes variance across expression levels
vsd = vst(dds)

# Display object information
vsd
dds

# Encode ERBB2 status as factors with two levels for easier labelling.
colData(vsd)$ERBB2 <- factor(
  ifelse(colData(vsd)$ERBB2 %in% c(1, TRUE, "1", "TRUE"),
         "Amplified",
         "Non-amplified"),
  levels = c("Non-amplified", "Amplified")
)


# Create PCA plot colored by ERBB2 status
# PCA reduces dimensionality to show major sources of variation
par(mfrow = c(1, 2))
plotPCA(vsd, intgroup = "ERBB2") +
  labs(color = "ERBB2 Status") +
  scale_color_manual(
    values = c(
      "Non-amplified" = "#33a02c",
      "Amplified"     = "black"
    )
  )
```

## Load libraries for pathway enrichment analysis

```{r, message=FALSE}
library(clusterProfiler)
library(enrichplot)
library(org.Hs.eg.db)
```

## Gene Ontology (GO) enrichment analysis

```{r, fig.height=7}
# Get significantly differentially expressed genes
res_sig = res[res$padj<0.05,]

# Separate into over-expressed and under-expressed genes
# log2FoldChange > 0: higher expression in ERBB2 amplified
# log2FoldChange < 0: lower expression in ERBB2 amplified
DE_over = rownames(res_sig[res_sig$log2FoldChange>0,])
DE_under = rownames(res_sig[res_sig$log2FoldChange<0,])

# GO enrichment for over-expressed genes
go_results_over = enrichGO(
  gene          = DE_over,
  OrgDb         = org.Hs.eg.db,
  keyType       = "SYMBOL",  
  ont           = "BP", 
  pAdjustMethod = "BH",      # Benjamini-Hochberg FDR correction
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

# Print and plot results
print(head(go_results_over))

# GO enrichment for under-expressed genes
go_results_under = enrichGO(
  gene          = DE_under,
  OrgDb         = org.Hs.eg.db,
  keyType       = "SYMBOL",  
  ont           = "BP", 
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

# Print and plot results
print(head(go_results_under))

# Create dot plots showing enriched GO terms
dotplot(go_results_under, showCategory=10) + ggtitle("Gene Ontology Enrichment Under Expressed")
dotplot(go_results_over, showCategory=10) + ggtitle("Gene Ontology Enrichment Over Expressed")
```

## View top GO enrichment results

```{r}
# Display descriptions of top 10 enriched GO terms
go_results_under[1:10,]$Description  # Under-expressed genes
go_results_over[1:10,]$Description   # Over-expressed genes
```

## KEGG pathway enrichment analysis

```{r, fig.height=7}
library(ReactomePA)
library(pathview)

# Convert gene symbols to Entrez IDs (required for KEGG)
# Note: bitr converts between gene ID types
gene_entrez_over <- bitr(
  DE_over,
  fromType = "SYMBOL",
  toType   = "ENTREZID",
  OrgDb    = org.Hs.eg.db
)

gene_entrez_under <- bitr(
  DE_under,
  fromType = "SYMBOL",
  toType   = "ENTREZID",
  OrgDb    = org.Hs.eg.db
)

# KEGG enrichment for over-expressed genes
kegg_results_over =  enrichKEGG(
  gene          = gene_entrez_over[,2],  # Use Entrez IDs (column 2)
  organism      = "human",   
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

# KEGG enrichment for under-expressed genes
kegg_results_under =  enrichKEGG(
  gene          = gene_entrez_under[,2],
  organism      = "human",   
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05
)

# Print and plot results
print(head(kegg_results_over))
dotplot(kegg_results_over, showCategory=10) + ggtitle("KEGG Pathway Enrichment Over Expressed")

print(head(kegg_results_under))
dotplot(kegg_results_under, showCategory=10) + ggtitle("KEGG Pathway Enrichment Under Expressed")
```

## View top KEGG pathway results

```{r}
# Display top 10 enriched KEGG pathways
kegg_results_over[1:10,]
kegg_results_under[1:10,] 
```

## Reactome pathway enrichment analysis

```{r}
# Reactome is another pathway database (more comprehensive than KEGG)
# Enrichment for over-expressed genes
reactome_results_over =  enrichPathway(
  gene          = gene_entrez_over[,2],  # Use Entrez IDs
  organism      = "human",   
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
)

# Enrichment for under-expressed genes
reactome_results_under =  enrichPathway(
  gene          = gene_entrez_under[,2],
  organism      = "human",   
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.05,
)
```

## Visualize Reactome pathway enrichment results

```{r, fig.height=7}
# Print and plot Reactome enrichment results
print(head(reactome_results_over))
dotplot(reactome_results_over, showCategory=10) + ggtitle("Reactome Pathway Enrichment Over Expressed")

print(head(reactome_results_under))
dotplot(reactome_results_under, showCategory=10) + ggtitle("Reactome Pathway Enrichment Under Expressed")
```

## View top Reactome pathway descriptions

```{r}
# Display descriptions of top 10 enriched Reactome pathways
reactome_results_over[1:10,]$Description   # Over-expressed genes
reactome_results_under[1:10,]$Description   # Under-expressed genes
```

## Tree plots showing relationships between enriched terms

```{r, fig.height=7, fig.width = 14}
# Tree plots show hierarchical relationships between enriched terms

# GO tree plots
go_results_under_pw = pairwise_termsim(go_results_under)
treeplot(go_results_under_pw)+ ggtitle("GO Enrichment Under Expressed")

go_results_over_pw = pairwise_termsim(go_results_over)
treeplot(go_results_over_pw)+ ggtitle("GO Enrichment Over Expressed")

# KEGG tree plots
kegg_results_under_pw = pairwise_termsim(kegg_results_under)
treeplot(kegg_results_under_pw)+ ggtitle("KEGG Enrichment Under Expressed")

kegg_results_over_pw = pairwise_termsim(kegg_results_over)
treeplot(kegg_results_over_pw)+ ggtitle("KEGG Enrichment Over Expressed")
```

# 4. Heatmap Analysis

## Heatmap of top differentially expressed genes

```{r}
# Get top 20 most significantly differentially expressed genes
# Order by adjusted p-value (smallest = most significant)
top_DE = order(res$padj)

# Extract expression data for top 20 genes from VST-transformed data
vsd_DE = assay(vsd)[top_DE[1:20],]

# Load pheatmap library for creating publication-quality heatmaps
library(pheatmap)

# Define colors for ERBB2 annotation (amplified vs non-amplified)
annotation_colors = list(
  ERBB2 = c(
    "non-amplified" = "lightgreen",
    "amplified"     = "#1f78b4"
  )
)

# Create annotation data frame for column (patient) annotations
annotation_col = data.frame(
  ERBB2 = factor(metadata[,3],
                 levels = c(0, 1),
                 labels = c("non-amplified", "amplified"))
)

rownames(annotation_col) = colnames(vsd)

# Create heatmap
# scale = 'row': normalize each gene (row) to show relative expression
# cluster_rows/cols: hierarchical clustering
pheatmap(
  vsd_DE,
  cluster_rows = TRUE,      # Cluster genes
  cluster_cols = TRUE,      # Cluster patients
  scale = 'row',            # Z-score normalization per gene
  show_colnames = FALSE,    
  show_rownames = TRUE,     # Show gene names
  annotation_col = annotation_col, 
  annotation_colors = annotation_colors)  # Color bar for ERBB2 status
```

# 5. Kaplan-Meier Survival Curve Analysis

## Load survival analysis library

```{r}
# Load library for survival analysis (Kaplan-Meier, Cox regression)
library(survival)
```

## Prepare data for survival analysis

```{r}
# Create survival outcome variables for patients with common IDs
# deceased: 1 if patient died, 0 if censored (still alive)
deceased = ifelse(data_patient[data_patient$X.Patient.Identifier %in% common_ids, col_OS] == "1:DECEASED", 1, 0)

# os_time: overall survival time in months
os_time = as.numeric(data_patient[data_patient$X.Patient.Identifier %in% common_ids,col_OS_T])

# Remove patients with survival time = 0 (invalid data)
idx = which(as.numeric(data_patient[data_patient$X.Patient.Identifier %in% common_ids,col_OS_T]) == 0)
remove_patient_ids = data_patient[idx,]$X.Patient.Identifier

# Check deceased status for patients with time = 0
deceased[which(os_time == 0)]

# Filter out patients with invalid survival times
keep = os_time > 0
os_time = os_time[keep]
deceased = deceased[keep]

# Get ERBB2 amplification status for survival analysis
# Filter to common IDs, exclude invalid survival time patients
ERBB2_status = cna_long |>
  filter(Patient_ID %in% common_ids & !(Patient_ID %in% remove_patient_ids)) |>
  filter(Hugo_Symbol == "ERBB2") |>
  mutate('status' = ifelse(CNA > 0, 1, 0))

ERBB2_status = ERBB2_status$status

# Create survival object (time, event)
y = Surv(time = os_time, event = deceased)

# Get differentially expressed genes for survival modeling
de_genes = rownames(res[res$padj < 0.05, ])

# Create feature matrix X: patients x genes
# Use VST-transformed expression of DE genes
# Filter to common IDs and exclude invalid survival time patients
X = t(assay(vsd)[ , colnames(assay(vsd)) %in% common_ids & 
                    !(colnames(assay(vsd)) %in% remove_patient_ids), 
                      drop = FALSE][de_genes, ])
```

## Lasso Cox regression for survival prediction

```{r}
# Load glmnet for regularized regression (Lasso)
library(glmnet)

# Set random seed for reproducibility
set.seed(1)

# Cross-validated Lasso Cox regression
# alpha = 1: Lasso penalty (L1 regularization)
# family = "cox": Cox proportional hazards model
# This selects genes that predict survival
fit = cv.glmnet( 
  x = X,           # Gene expression matrix (patients x genes)
  y = y,           # Survival object (time, event)
  family = "cox",
  alpha = 1)

# Extract optimal lambda values
lambda_opt = fit$lambda.min   # Lambda with minimum cross-validation error
lambda_1se = fit$lambda.1se   # Lambda within 1 standard error of minimum (more conservative)
```

## Extract selected genes from Lasso model

```{r}
# Get coefficients at optimal lambda
coef_lasso <- coef(fit, s = lambda_opt)

# Find which genes have non-zero coefficients (selected by Lasso)
active_idx <- which(coef_lasso != 0)

# Count how many genes were selected
length(active_idx)

# Get names of selected genes
selected_genes <- rownames(coef_lasso)[active_idx]
```

## Survival analysis and Kaplan-Meier curves

```{r}
# Predict linear predictor (risk score) for each patient
lp <- predict(fit, newx = X, s = lambda_opt, type = "link")

# Check distribution of risk scores
summary(lp)
length(unique(lp))

# Create risk groups: High risk if above median, Low risk if below
risk_group <- ifelse(lp > median(lp), "High", "Low")
risk_group = factor(risk_group, levels = c("Low", "High"))
table(risk_group)

# Kaplan-Meier curve 1: Survival by ERBB2 amplification status
fit_km <- survfit(y ~ ERBB2_status)

plot(fit_km, 
     main = "Kaplan Meier Curve", 
     xlab = "Time (in months)", ylab = "Survival probability", 
     col = c("steelblue", "tomato"))

legend("topright",
       legend = c("ERBB2 non-amp", "ERBB2 amp"),
       col = c("steelblue", "tomato"),
       lty = 1,
       lwd = 2,
       bty = "n")

# Kaplan-Meier curve 2: Survival by gene expression risk group
fit_km2 <- survfit(y ~ risk_group)

plot(fit_km2, 
     main = "Kaplan Meier Curve", 
     xlab = "Time (in months)", ylab = "Survival probability", 
     col = c("steelblue", "tomato"))

legend("topright",
       legend = levels(risk_group),
       col = c("steelblue", "tomato"),
       lty = 1,
       lwd = 2,
       bty = "n")

# Log-rank test: test if survival curves are significantly different
survdiff(y ~ risk_group)      # Gene expression risk groups
survdiff(y ~ ERBB2_status)    # ERBB2 amplification status
```

\
